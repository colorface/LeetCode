//
//  __insertionSort.c
//  LeetCode
//
//  Created by AIR on 2018/9/13.
//  Copyright © 2018年 com.TX.NordVPN. All rights reserved.
//

#include <stdio.h>

// name ------------ 插入排序
// 分类 ------------- 内部比较排序
// 数据结构 ---------- 数组
// 最差时间复杂度 ---- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)
// 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)
// 平均时间复杂度 ---- O(n^2)
// 所需辅助空间 ------ O(1)
// 稳定性 ------------ 稳定

/*
 插入排序是一种简单直观的排序算法。它的工作原理非常类似于我们抓扑克牌
 对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，
 找到相应位置并插入。
 
 插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），
 因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。
 
 具体算法描述如下：
 ①从第一个元素开始，该元素可以认为已经被排序
 ②取出下一个元素，在已经排序的元素序列中从后向前扫描
 ③如果该元素（已排序）大于新元素，将该元素移到下一位置
 ④重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
 ⑤将新元素插入到该位置后
 ⑥重复步骤2~5
 
 说明：
 */


void insertionSort(int *a, int len) {
    
    for (int i=1; i<len; i++) {         // 类似抓扑克牌排序
        
        int cur = a[i];                 // 右手抓到一张扑克牌
        int j = i - 1;                  // 拿在左手上的牌总是排序好的
        
        while (j>=0 && a[j] > cur) {    // 将抓到的牌与手牌从右向左进行比较
            a[j+1] = a[j];              // 如果该手牌比抓到的牌大，就将其右移
            j--;
        }
        a[j+1] = cur;                   // 直到该手牌比抓到的牌小(或二者相等)，
                                        // 将抓到的牌插入到该手牌右边
                                        //(相等元素的相对次序未变，所以插入排序是稳定的)
    }
}


// name -------------二分插入排序
// 分类 -------------- 内部比较排序
// 数据结构 ---------- 数组
// 最差时间复杂度 ---- O(n^2)
// 最优时间复杂度 ---- O(nlogn)
// 平均时间复杂度 ---- O(n^2)
// 所需辅助空间 ------ O(1)
// 稳定性 ------------ 稳定

/*
 当n较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，
 所以当元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。
 二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。
 */

void insertionSortDichotomy(int *a, int len)
{
    for (int i = 1; i < len; i++)
    {
        int cur = a[i];                   // 右手抓到一张扑克牌
        int left = 0;                     // 拿在左手上的牌总是排序好的，所以可以用二分法
        int right = i - 1;                // 手牌左右边界进行初始化
        while (left <= right)             // 采用二分法定位新牌的位置
        {
            int mid = (left + right) / 2;
            if (a[mid] > cur)
                right = mid - 1;
            else
                left = mid + 1;
        }
        for (int j = i - 1; j >= left; j--)//将欲插入新牌位置右边的牌整体向右移动一个单位
        {
            a[j + 1] = a[j];
        }
        a[left] = cur;                    // 将抓到的牌插入手牌
    }
}


// name ------------- shell sort 希尔排序
// 分类 -------------- 内部比较排序
// 数据结构 ---------- 数组
// 最差时间复杂度 ---- 根据步长序列的不同而不同。已知最好的为O(n(logn)^2)
// 最优时间复杂度 ---- O(n)
// 平均时间复杂度 ---- 根据步长序列的不同而不同。
// 所需辅助空间 ------ O(1)
// 稳定性 ------------ 不稳定

/*
 希尔排序，也叫递减增量排序，是插入排序的一种更高效的改进版本。希尔排序是不稳定的排序算法。
 希尔排序是基于插入排序的以下两点性质而提出改进方法的：
 
 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位
 希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终
 位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这
 步，需排序的数据几乎是已排好的了（此时插入排序较快）。
 
 　　假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n^2)的排序（冒泡排序或
 直接插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数
 据，所以小数据只需进行少数比较和交换即可到正确位置。
 
 
 
 希尔排序是不稳定的排序算法，虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排
 序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱。
 　　
 比如序列：{ 3, 5, 10, 8, 7, 2, 8, 1, 20, 6 }，h=2时分成两个子序列 { 3, 10, 7, 8, 20 }
 和  { 5, 8, 2, 1, 6 } ，未排序之前第二个子序列中的8在前面，现在对两个子序列进行插入排序，得到
 { 3, 7, 8, 10, 20 } 和 { 1, 2, 5, 6, 8 } ，即 { 3, 1, 7, 2, 8, 5, 10, 6, 20,
 8 } ，两个8的相对次序发生了改变。
 

*/

void ShellSort(int *a, int len)
{
    int h = 0;
    while (h <= len)                          // 生成初始增量
    {
        h = 3 * h + 1;
    }
    while (h >= 1)
    {
        for (int i = h; i < len; i++)
        {
            int j = i - h;
            int cur = a[i];
            while (j >= 0 && a[j] > cur)
            {
                a[j + h] = a[j];
                j = j - h;
            }
            a[j + h] = cur;
        }
        h = (h - 1) / 3;                    // 递减增量
    }
}
